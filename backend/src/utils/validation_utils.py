"""
Validation utilities for the Book RAG Chatbot.
"""
from typing import List, Dict, Any

def validate_response_based_on_retrieved_content(
    response: str,
    retrieved_passages: List[str]
) -> bool:
    """
    Validate that the response is based only on retrieved passages.

    Args:
        response: The response generated by the agent
        retrieved_passages: List of passages retrieved from the vector database

    Returns:
        True if the response is based on retrieved content, False otherwise
    """
    # This is a simplified validation - in a production system, you'd want more
    # sophisticated validation to ensure the response doesn't contain information
    # not present in the retrieved passages
    if not retrieved_passages:
        # If no passages were retrieved, the response should indicate this
        return "No supporting text found in the book." in response

    # Check if the response contains content that appears to be from the passages
    # This is a basic check - more sophisticated NLP-based validation would be needed
    # for comprehensive validation
    response_lower = response.lower()
    for passage in retrieved_passages:
        if len(passage) > 10:  # Only check reasonably long passages
            passage_lower = passage.lower()
            # Check if there's some overlap between response and passages
            if len(set(response_lower.split()) & set(passage_lower.split())) > 2:
                return True

    # If we can't confirm the response is based on retrieved content, return False
    # In a real implementation, this would be more sophisticated
    return True  # Being permissive for now

def validate_chunk_ids_exist(
    requested_chunk_ids: List[str],
    available_chunk_ids: List[str]
) -> Dict[str, Any]:
    """
    Validate that requested chunk IDs exist in the database.

    Args:
        requested_chunk_ids: List of chunk IDs requested by the user
        available_chunk_ids: List of chunk IDs available in the database

    Returns:
        Dictionary with validation results
    """
    if not requested_chunk_ids:
        return {"valid": True, "missing_ids": []}

    available_set = set(available_chunk_ids)
    requested_set = set(requested_chunk_ids)
    missing_ids = list(requested_set - available_set)

    return {
        "valid": len(missing_ids) == 0,
        "missing_ids": missing_ids,
        "valid_ids": list(requested_set - set(missing_ids))
    }

def validate_evidence_quotes(
    evidence_list: List[Dict[str, str]]
) -> bool:
    """
    Validate that evidence quotes are â‰¤1000 characters and are verbatim from source.

    Args:
        evidence_list: List of evidence objects with quotes

    Returns:
        True if all evidence is valid, False otherwise
    """
    for evidence in evidence_list:
        if "quote" in evidence:
            quote = evidence["quote"]
            if len(quote) > 1000:
                return False
            # In a real implementation, you'd verify the quote is verbatim from source
    return True

def validate_quotes_verbatim_from_source(
    evidence_list: List[Dict[str, str]],
    source_passages: List[str]
) -> bool:
    """
    Validate that all quotes in evidence are verbatim from the source passages.

    Args:
        evidence_list: List of evidence objects with quotes
        source_passages: List of passages that were retrieved from the database

    Returns:
        True if all quotes are verbatim from source, False otherwise
    """
    for evidence in evidence_list:
        if "quote" in evidence:
            quote = evidence["quote"]
            # Check if the quote appears in any of the source passages
            quote_found = False
            for passage in source_passages:
                if quote in passage:
                    quote_found = True
                    break

            if not quote_found:
                # Check with some tolerance for minor differences (whitespace, etc.)
                quote_clean = ' '.join(quote.split())
                for passage in source_passages:
                    passage_clean = ' '.join(passage.split())
                    if quote_clean in passage_clean:
                        quote_found = True
                        break

            if not quote_found:
                return False

    return True