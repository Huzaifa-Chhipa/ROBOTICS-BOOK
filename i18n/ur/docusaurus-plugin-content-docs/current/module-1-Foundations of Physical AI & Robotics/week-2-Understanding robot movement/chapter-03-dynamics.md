import PrerequisiteDisplay from '@site/src/components/PrerequisiteDisplay';

---
title: "روبوٹ ڈائینامکس کے اصول"
description: "روبوٹ ڈائینامکس کے بنیادی تصورات."
slug: "chapter-03-dynamics"
week: 2
module: "مODULE 1: فزیکل AI اور روبوٹکس کی بنیاد"
prerequisites: ["chapter-02-kinematics"]
learningObjectives:
  - روبوٹ ڈائینامکس کی بنیاد اور اس کے کنیمیٹکس سے فرق کو سمجھیں۔
  - ماس، انرشیا، اور ان کے اثر کو روبوٹ حرکت میں سمجھیں۔
  - نیوٹن-ایولر مساوات کا اطلاق کریں تاکہ روبوٹ لنکس میں زور اور ٹورک کا تجزیہ کیا جا سکے۔
  - مساوات کے ڈائینامک کے منظم ماخذ کے لیے لاگرانجین فارمولیشن کو سمجھیں۔
  - روبوٹ کنٹرول، سیمولیشن، اور ڈیزائن میں ڈائینامکس کی اہمیت کو تسلیم کریں۔
estimatedTime: 180
difficultyLevel: "متوسط"
sidebar_label: "3. قوتیں، ڈائینامکس، اور ایکٹو ایشن"
position: 1
---

<PrerequisiteDisplay prerequisites={frontMatter.prerequisites} />

# ⚖️ روبوٹ ڈائینامکس کے اصول: قوتوں اور حرکت کو سمجھنا

کنیمیٹکس کے ذریعے روبوٹ حرکت کی جیومیٹری کو تلاش کرنے کے بعد، ہم اب **روبوٹ ڈائینامکس** کی طرف منتقل ہوتے ہیں۔ جب کنیمیٹکس "روبوٹ کا ختم کہاں ہے؟" یا "ہندسہ کے لحاظ سے اس تک کیسے پہنچا جائے؟" کا جواب دیتا ہے، تو ڈائینامکس اسے ایک اہم قدم آگے بڑھاتا ہے: یہ یہ سمجھتا ہے کہ **کیوں** اور **کیسے** وہ حرکت ہوتی ہے۔ ڈائینامکس روبوٹ حرکت کو پیدا کرنے والی قوتوں اور ٹورک کا مطالعہ ہے، جس میں تمام روبوٹ اجزاء کے ماس، انرشیا، اور تعاملات کو مدنظر رکھا جاتا ہے۔ 🚀

یہ باب کنیمیٹکس کی سمجھ کی بنیاد پر تعمیر کرے گا اور روبوٹ لنکس کی جسمانی خصوصیات، جیسے ان کا ماس اور انرشیا، اور ان خصوصیات کے حرکت پر بنیادی اثر کو متعارف کرائے گا۔ ہم ڈائینامک مساوات حاصل کرنے کے دو بنیادی فارمولیشنز میں گہرائی میں جائیں گے: **نیوٹن-ایولر فارمولیشن**، جو انفرادی لنکس کے لیے ایک جھلک دینے والے، تکراری نقطہ نظر فراہم کرتا ہے، اور **لاگرانجین فارمولیشن**، جو پیچیدہ متعدد لنکس کے نظام کے لیے ایک زیادہ مہذب اور منظم طریقہ فراہم کرتا ہے۔

کائینیٹک اور ممکنہ توانائی، انرشیا ٹینسر، اور گریویٹیشنل اثرات جیسے کلیدی تصورات کا تجزیہ روبوٹ کے رویے میں ان کے کردار کو سمجھنے کے لیے کیا جائے گا۔ روبوٹ ڈائینامکس کی ایک مضبوط سمجھ روبوٹک نظام کے لیے درست کنٹرول، حقیقی سیمولیشن، اور بہترین ڈیزائن کے لیے ناگزیر ہے، کیونکہ یہ ہمیں یہ پیش گوئی کرنے کے قابل بناتی ہے کہ روبوٹ مختلف قوتوں کے تحت کیسے ری ایکٹ کرے گا اور مطلوبہ اعمال کے لیے ضروری کنٹرول ان پٹ کو درست طور پر منصوبہ بند کر سکتے ہیں۔ ✨

---
## کنیمیٹکس بمقابلہ ڈائینامکس: ایک بنیادی تمیز 🧠💪

زیادہ گہرائی میں جانے سے پہلے، کنیمیٹکس اور ڈائینامکس کے درمیان واضح تمیز کرنا ضروری ہے:

| خصوصیت | کنیمیٹکس (حرکت کا ہندسہ) | ڈائینامکس (حرکت کے اسباب) |
| :---------------- | :--------------------------------------------------- | :------------------------------------------------------ |
| **مرکز** | پوزیشن، جہت، رفتار، تیزی (صرف ہندسہ کے رشتے) | قوتیں، ٹورک، ماس، انرشیا، توانائی (حرکت کے اسباب) |
| **پوچھے گئے سوالات** | یہ کہاں ہے؟ یہ کتنا تیز چل رہا ہے؟ | یہ کیوں چل رہا ہے؟ کتنی قوت کی ضرورت ہے؟ |
| **ان پٹ** | جوڑ کے اینگلز/رفتار | جوڑ کے اینگلز/رفتار/تیزی، بیرونی قوتیں |
| **آؤٹ پٹ** | ختم کی پوزیشن/رفتار | جوڑ کے ٹورک/قوتیں، نتیجہ خیز حرکت |
| **پیچیدگی** | عام طور پر سادہ، الجبر/ہندسہ | زیادہ پیچیدہ، میں تفریقی مساوات شامل ہیں |
| **ضرورت** | کوئی نہیں (کنیمیٹکس کے لیے) | کنیمیٹکس (ڈائینامکس کنیمیٹکس کی تفصیل پر تعمیر ہوتا ہے) |

ڈائینامکس کو سمجھنا مندرجہ ذیل کے لیے اہم ہے:
* **درست کنٹرول:** روبوٹ کو درست طور پر چلانے کے لیے، ہمیں یہ جاننا ہوگا کہ ہر جوڑ پر کون سے ٹورک انرشیا، گریویٹی، اور بیرونی لوڈ کو overcome کرنے کے لیے درکار ہیں۔
* **حقیقی سیمولیشن:** مصنوعی ماحول میں روبوٹ کے رویے کو درست طور پر سیمولیٹ کرنے کے لیے ڈائینامک ماڈلز کی ضرورت ہوتی ہے۔
* **بہترین ڈیزائن:** انجینئر ڈائینامک تجزیہ کا استعمال مناسب موترز، گیئرباکس، اور مواد کو منتخب کرنے کے لیے کرتے ہیں، تاکہ روبوٹ طاقتور ہو لیکن توانائی کے لحاظ سے کارآمد بھی ہو۔
* **حفاظت:** اثرات یا غیر متوقع لوڈ کے تحت روبوٹ کا رد عمل توقع کرنا حفاظت کے لیے اہم ہے۔

---
## کلیدی ڈائینامک تصورات ⚙️

کئی بنیادی جسمانی تصورات روبوٹ ڈائینامکس کی بنیاد ہیں:

### ماس اور انرشیا ⚖️

* **ماس (m):** ایک چیز کی تیزی میں مزاحمت کی ایک پیمائش (لکیری انرشیا)۔ روبوٹ کا ہر لنک ایک ماس رکھتا ہے جو اس کے مرکز کے ماس پر مرکوز ہوتا ہے۔
* **انرشیا کا لمحہ (I):** ایک چیز کی اس کی گردش کی حرکت میں تبدیلی کے خلاف مزاحمت کی ایک پیمائش (گردشی انرشیا)۔ ایک سخت جسم کے لیے، اس کو ایک **انرشیا ٹینسر** (ایک 3x3 میٹرکس) کے ذریعے ظاہر کیا جاتا ہے نہ کہ ایک واحد سکیلر قیمت، کیونکہ ایک چیز کی گردش کے خلاف مزاحمت گردش کے محور پر منحصر ہوتی ہے۔
  * `I = ∫ r^2 dm` (ایک محور کے لیے، سادہ)
  * انرشیا ٹینسر کوآرڈینیٹ فریم کے تناظر میں ماس کی تقسیم کو بیان کرتا ہے۔
* **اثر:** بھاری لنکس اور زیادہ لمحہ انرشیا کو تیز کرنے یا سست کرنے کے لیے زیادہ قوتیں/ٹورک درکار ہوتے ہیں، جو براہ راست موٹر سائز اور توانائی کی کھپت کو متاثر کرتے ہیں۔

### گریویٹی کے اثرات 🌍

گریویٹی ہر روبوٹ لنک پر مستقل طور پر ایک قوت ڈالتی ہے۔ یہ قوت جوڑوں پر ٹورک پیدا کرتی ہے، جنہیں روبوٹ کے ایکٹو ایٹرز کو مزاحمت کرنا پڑتی ہے، خاص طور پر جب ایک پوزیشن کو تھامے رکھنا یا آہستہ چلنا ہو۔
* **ممکنہ توانائی (V):** ایک نظام میں ذخیرہ شدہ توانائی جو اس کی گریویٹیشنل فیلڈ میں پوزیشن کی وجہ سے ہوتی ہے۔ روبوٹ لنک کے لیے، `V = m * g * h`، جہاں `h` اس کے مرکز کے ماس کی اونچائی ہے۔ ممکنہ توانائی میں تبدیلی لاگرانجین فارمولیشن میں اہم ہے۔

### بیرونی قوتیں اور ٹورک 🤝

روبوٹ اکثر اپنے ماحول کے ساتھ باتچیت کرتے ہیں، قوتیں لگاتے ہیں (مثلاً ایک چیز کو تھامنا) یا بیرونی قوتوں کا تجربہ کرتے ہیں (مثلاً تصادم، سطح کے خلاف دھکیلنا)۔ ان بیرونی تعاملات کو ڈائینامک مساوات میں شامل کیا جانا چاہیے تاکہ حرکت کی درست پیش گوئی کی جا سکے یا ضروری جوڑ کی کاوشوں کا حساب لگایا جا سکے۔

### فرکشن 💨

تمام میکانیکل جوڑوں اور ڈرائیو سسٹم (مثلاً موٹر، گیئرباکس) میں فرکشن موجود ہوتا ہے۔ یہ حرکت کی مزاحمت کرتا ہے اور قابل ذکر توانائی کو ضائع کر سکتا ہے۔ جبکہ تعارفی ڈائینامکس میں اسے اکثر سادہ بنایا جاتا ہے، یہ حقیقی دنیا کے روبوٹ کی کارکردگی اور کنٹرول میں ایک اہم عنصر ہے۔

---
## نیوٹن-ایولر فارمولیشن: ایک تکراری نقطہ نظر ➡️↩️

نیوٹن-ایولر فارمولیشن لکیری حرکت (`F = ma`) کے لیے نیوٹن کے دوسرے قانون اور گردشی حرکت (`τ = Iα + ω × (Iω)`) کے لیے ایولر کے دوسرے قانون کو لنک سے لنک تک تکرار کے ساتھ لاگو کرتا ہے۔ اسے اکثر حقیقی وقت کے کنٹرول (معکوس ڈائینامکس) میں اس کی معلوماتی کارکردگی اور اس کی جھلک دینے والی جسمانی تشریح کی وجہ سے ترجیح دی جاتی ہے۔

عمل میں دو اہم پاس شامل ہیں:

1. **فارورڈ پاس (بیس سے ختم تک):** ہر لنک پر کام کرنے والی رفتار، تیزی، اور قوتوں کا حساب لگاتا ہے *بیس سے ختم* تک۔ یہ پاس کنیمیٹک معلومات کو پھیلاتا ہے۔
2. **بیک ورڈ پاس (ختم سے بیس تک):** ہر لنک کے ذریعے اس سے پچھلے لنک پر ڈالی گئی قوتوں اور ٹورک کا حساب لگاتا ہے (اور اس طرح ضروری جوڑ ٹورک) *ختم سے بیس* تک۔ یہ پاس ڈائینامک قوتوں اور ٹورک کو پھیلاتا ہے۔

### نیوٹن-ایولر مساوات (ایک واحد لنک `i` کے لیے سادہ):

**فارورڈ پاس (لنک `i` کا لنک `i-1` کے مقابلہ میں):**
* مرکز کے ماس کی لکیری رفتار: `v_i = v_{i-1} + ω_{i-1} × r_{i-1,i} + ω_i × r_{i,c_i}`
* گردشی رفتار: `ω_i = R_{i-1}^i * ω_{i-1} + θ̇_i * z_i` (برائے گردشی جوڑ)
* مرکز کے ماس کی لکیری تیزی: `a_i = a_{i-1} + α_{i-1} × r_{i-1,i} + ω_{i-1} × (ω_{i-1} × r_{i-1,i}) + α_i × r_{i,c_i} + ω_i × (ω_i × r_{i,c_i})`
* گردشی تیزی: `α_i = R_{i-1}^i * α_{i-1} + θ̈_i * z_i + ω_i × (θ̇_i * z_i)`

**بیک ورڈ پاس (جوڑ `i` پر قوتوں/ٹورکس):**
* لنک `i` پر نیٹ قوت: `F_i = m_i * a_i`
* لنک `i` پر مرکز کے ماس کے بارے میں نیٹ مومینٹ (ٹورک): `N_i = I_i * α_i + ω_i × (I_i * ω_i)`
* لنک `i` کے ذریعے لنک `i-1` پر ڈالی گئی قوت: `f_{i,i-1} = f_{i+1,i} + F_i` (اگلے لنک پر قوتوں کا مجموعہ + موجودہ لنک پر نیٹ قوت)
* لنک `i` کے ذریعے لنک `i-1` پر ڈالا گیا مومینٹ: `n_{i,i-1} = n_{i+1,i} + N_i + r_{i,c_i} × F_i + r_{i,i+1} × f_{i+1,i}` (مومنٹس کا مجموعہ)
* ضروری جوڑ ٹورک: `τ_i = (n_{i,i-1})ᵀ * z_i` (جوڑ محور پر پروجیکشن)

*(نوٹ: یہ مساوات بہت سادہ ہیں۔ مکمل نیوٹن-ایولر فارمولیشن میں کوآرڈینیٹ فریم کے درمیان ویکٹر کیلکولس اور ٹرانسفارمیشن شامل ہیں۔)*

```python
# نمونہ کوڈ مثال: نیوٹن-ایولر معکوس ڈائینامکس (کانسیپچوئل)
# ایک واحد گردشی جوڑ لنک کے لیے (سادہ)

import numpy as np

def newton_euler_inverse_dynamics_conceptual(joint_angles, joint_velocities, joint_accelerations,
                                          link_mass, link_com, link_inertia_tensor, gravity_vector):
    """
    نیوٹن-ایولر کا استعمال کرتے ہوئے ایک واحد لنک کے لیے کانسیپچوئل معکوس ڈائینامکس۔
    یہ بہت سادہ ہے اور صرف وضاحت کے مقصد کے لیے ہے۔
    حقیقی نافذ کاری میں فارورڈ/بیک ورڈ پاس اور کوآرڈینیٹ ٹرانسفارم شامل ہیں۔

    آرگس:
        joint_angles (list): [theta]
        joint_velocities (list): [theta_dot]
        joint_accelerations (list): [theta_double_dot]
        link_mass (float): لنک کا ماس۔
        link_com (np.array): پچھلے جوڑ سے مرکز کے ماس کا ویکٹر۔
        link_inertia_tensor (np.array): 3x3 انرشیا ٹینسر COM کے بارے میں۔
        gravity_vector (np.array): [gx, gy, gz]

    واپسی:
        float: جوڑ پر ضروری ٹورک۔
    """
    theta = joint_angles[0]
    theta_dot = joint_velocities[0]
    theta_double_dot = joint_accelerations[0]

    # تصور کریں کہ صرف سادہ سطحی حرکت وضاحت کے لیے
    # لنک کی گردشی رفتار (پچھلے فریم کے مقابلہ میں)
    omega = np.array([0, 0, theta_dot]) # فرض کریں کہ Z محور کے گرد گردش
    # لنک کی گردشی تیزی
    alpha = np.array([0, 0, theta_double_dot])

    # مرکز کے ماس کی لکیری تیزی (بہت سادہ - پچھلے لنک کی حرکت کو نظر انداز کرنا)
    # اس میں پچھلے لنکس اور گردشی تیزیوں کے پیچیدہ ا Terms شامل ہوں گے
    linear_acceleration_com = np.array([0,0,0]) # جگہ دار۔ حقیقی حساب پیچیدہ ہے۔

    # مؤثر لکیری تیزی گریویٹی کو شامل کرتے ہوئے
    effective_linear_acceleration_com = linear_acceleration_com - gravity_vector

    # لنک پر نیٹ قوت (F = ma)
    F_net = link_mass * effective_linear_acceleration_com

    # مرکز کے ماس کے بارے میں نیٹ مومینٹ (tau = I*alpha + omega x (I*omega))
    # 2D کے لیے، I*alpha عام طور پر صرف Iz*alpha_z ہے
    N_net = link_inertia_tensor[2,2] * alpha[2] # Z محور کی گردش کے لیے سادہ

    # قوتوں اور مومنٹس کو پیچھے کی طرف پھیلانا (کانسیپچوئل)
    # یہ اسٹیپ بیک ورڈ پاس کا دل ہے، اگلے لنکس سے تمام قوتوں/مومنٹس کو جمع کرنا
    # اور انہیں موجودہ جوڑ پر لاگو کرنا۔

    # موجودہ جوڑ پر ضروری ٹورک (بہت سادہ)
    # یہ کانسیپچوئل کا ایک مجموعہ ہے۔ حقیقت میں، یہ جوڑ محور کے ساتھ ڈوٹ پروڈکٹس میں شامل ہے۔
    # سادگی: فرض کریں کہ link_com موجودہ جوڑ سے COM تک ایک ویکٹر ہے۔
    # torque = cross(link_com, F_net) + N_net
    # یہاں، ہم صرف N_net کو سادگی کے لیے واپس کریں گے کیونکہ F_net کراس پروڈکٹ نمونہ کوڈ کے لیے زیادہ پیچیدہ ہے
    required_torque = N_net # وضاحت کے لیے بہت سادہ

    return required_torque

if __name__ == "__main__":
    # مثال قیمتیں (بہت سادہ)
    link_m = 1.0 # kg
    link_com_vec = np.array([0.5, 0, 0]) # COM 0.5m X کے ساتھ
    link_I_tensor = np.diag([0.01, 0.01, 0.1]) # انرشیا ٹینسر (سادہ)
    grav = np.array([0, -9.81, 0]) # گریویٹی -Y سمت میں کام کر رہی ہے

    # ایک جوڑ کے لیے مطلوبہ حرکت
    q = [math.radians(30)] # 30 ڈگری
    q_dot = [math.radians(10)] # 10 deg/s
    q_double_dot = [math.radians(5)] # 5 deg/s^2

    # ضروری ٹورک کا حساب لگائیں
    tau = newton_euler_inverse_dynamics_conceptual(q, q_dot, q_double_dot,
                                                link_m, link_com_vec, link_I_tensor, grav)
    print(f"کانسیپچوئل طور پر ضروری جوڑ ٹورک: {tau:.2f} Nm")
```

---
## لاگرانجین فارمولیشن: ایک توانائی پر مبنی نقطہ نظر ⚡️

لاگرانجین فارمولیشن پیچیدہ روبوٹک نظام کے لیے حرکت کی مساوات حاصل کرنے کا ایک متبادل، اکثر زیادہ منظم نقطہ نظر فراہم کرتا ہے۔ یہ توانائی کے اصولوں پر مبنی ہے نہ کہ قوت کے توازن پر اور اندرونی قوتوں اور قیدوں کے ساتھ براہ راست ن dealingے۔

مرکزی خیال یہ ہے کہ نظام کا **لاگرانجین (L)** کو بیان کرنا، جو نظام کی کل کائینیٹک توانائی (T) اور کل ممکنہ توانائی (V) کے درمیان فرق ہے:

`L = T - V`

جہاں:
* **کائینیٹک توانائی (T):** حرکت کی توانائی۔ ایک روبوٹ کے لیے، اس میں اس کے تمام لنکس کی لکیری اور گردشی کائینیٹک توانائی شامل ہے۔ `T = (1/2) * m * v^2 + (1/2) * I * ω^2` (ایک واحد جسم کے لیے سادہ)۔
* **ممکنہ توانائی (V):** پوزیشن کی وجہ سے ذخیرہ شدہ توانائی (زیادہ تر گریویٹیشنل ممکنہ توانائی روبوٹس کے لیے)۔ `V = m * g * h`۔

ایک بار لاگرانجین کی تعریف کے بعد، ہر جنرلائزڈ کوآرڈینیٹ (عام طور پر جوڑ متغیرات) کے لیے حرکت کی مساوات کو **ایولر-لاگرانج مساوات** کا استعمال کرتے ہوئے حاصل کیا جا سکتا ہے:

`d/dt (∂L/∂q̇_i) - ∂L/∂q_i = Q_i`

جہاں:
* `q_i` `i`-ویں جنرلائزڈ کوآرڈینیٹ ہے (مثلاً ایک جوڑ اینگل `θ_i` یا ڈسپلیسمنٹ `d_i`)۔
* `q̇_i` `i`-ویں جنرلائزڈ کوآرڈینیٹ کا وقت کا ڈیریویٹو ہے (جوڑ رفتار)۔
* `Q_i` `i`-ویں جنرلائزڈ کوآرڈینیٹ پر کام کرنے والی غیر محفوظ قوتوں/ٹورکس کی نمائندگی کرتا ہے (مثلاً جوڑ ایکٹو ایشن ٹورک، فرکشن، بیرونی قوتوں)۔

ایولر-لاگرانج مساوات کو لاگو کرنے کا نتیجہ دوسرے درجہ کی تفریقی مساوات کا ایک سیٹ ہے جو روبوٹ کے ڈائینامکس کی وضاحت کرتا ہے اس شکل میں:

`M(q)q̈ + C(q,q̇)q̇ + G(q) = τ`

جہاں:
* `q` جنرلائزڈ کوآرڈینیٹس (جوڑ اینگلز/ڈسپلیسمنٹس) کا ویکٹر ہے۔
* `M(q)` **ماس میٹرکس** (یا انرشیا میٹرکس) ہے، جو روبوٹ کی کنفیگریشن پر منحصر ہے۔
* `C(q,q̇)q̇` **کوریولس اور سینٹری فیوگل قوتوں** کی نمائندگی کرتا ہے، جو گردشی حرکات سے پیدا ہوتے ہیں اور جوڑ کی پوزیشن اور رفتار پر منحصر ہیں۔
* `G(q)` **گریویٹی ویکٹر** ہے، جو گریویٹی کی وجہ سے ٹورک کی نمائندگی کرتا ہے، جو جوڑ کی پوزیشن پر منحصر ہے۔
* `τ` **جنرلائزڈ قوتوں/ٹورکس** کا ویکٹر ہے جو جوڑ پر لگایا جاتا ہے (ایکٹو ایٹر ٹورک)۔

### لاگرانجین فارمولیشن کے فوائد:
* **منظم:** پیچیدہ نظام کے لیے حرکت کی مساوات حاصل کرنے کے لیے ایک صاف ریسیپ فراہم کرتا ہے۔
* **سکیلر مقداریں:** سکیلر توانائی مقداریں سے ن dealingے، جس سے ویکٹر بیسڈ قوت کے تجزیہ کے مقابلہ میں ریاضی کو آسان بنا دیتا ہے۔
* **کوئی اندرونی قوتیں:** خود بخود اندرونی قید قوتوں کو براہ راست حساب کے بغیر شامل کر لیتا ہے۔

### لاگرانجین فارمولیشن کے نقصانات:
* نیوٹن-ایولر کے مقابلہ میں کم جھلک دینے والا جسمانی تشریح۔
* کچھ ایپلی کیشنز کے لیے معلوماتی طور پر بھاری ہو سکتا ہے، خاص طور پر معکوس ڈائینامکس کے لیے۔

```python
# نمونہ کوڈ مثال: لاگرانجین فارمولیشن (کانسیپچوئل)
# ایک واحد پینڈولم کے لیے (1 DoF)

import sympy
from sympy import symbols, sin, cos, diff
from sympy.physics.vector import dynamicsymbols

def lagrangian_dynamics_single_pendulum_conceptual(m, L, g):
    """
    ایک واحد پینڈولم کے لیے کانسیپچوئل لاگرانجین ڈائینامکس کا ماخذ۔
    علامتی تفریق کے لیے SymPy کا استعمال کرتا ہے۔

    آرگس:
        m (sympy.Symbol): پینڈولم باب کا ماس۔
        L (sympy.Symbol): پینڈولم ایرم کی لمبائی۔
        g (sympy.Symbol): گریویٹیشنل ایکسلریشن۔

    واپسی:
        sympy.Eq: پینڈولم کے لیے حرکت کی مساوات۔
    """
    # جنرلائزڈ کوآرڈینیٹ
    theta = dynamicsymbols('theta') # اینگل
    t = symbols('t')
    theta_dot = diff(theta, t) # گردشی رفتار

    # باب کی پوزیشن (فرض کریں کہ ابتداء میں مڑتا ہوا)
    x = L * sin(theta)
    y = -L * cos(theta) # منفی کیونکہ y-ایکسز عام طور پر اوپر کی طرف اشارہ کرتا ہے
    # باب کی رفتار
    x_dot = diff(x, t)
    y_dot = diff(y, t)

    # کائینیٹک توانائی (T)
    T = sympy.Rational(1, 2) * m * (x_dot**2 + y_dot**2)

    # ممکنہ توانائی (V)
    V = m * g * y

    # لاگرانجین (L = T - V)
    L_expr = T - V

    # ایولر-لاگرانج مساوات: d/dt (∂L/∂θ̇) - ∂L/∂θ = Q
    # سادگی کے لیے کوئی بیرونی ٹورک (Q=0) کا فرض کریں

    # ∂L/∂θ̇
    partial_L_wrt_theta_dot = diff(L_expr, theta_dot)

    # d/dt (∂L/∂θ̇)
    dt_partial_L_wrt_theta_dot = diff(partial_L_wrt_theta_dot, t)

    # ∂L/∂θ
    partial_L_wrt_theta = diff(L_expr, theta)

    # حرکت کی مساوات
    eom = sympy.Eq(dt_partial_L_wrt_theta_dot - partial_L_wrt_theta, 0)

    # سادہ کریں اور واپس کریں
    return sympy.simplify(eom)

if __name__ == "__main__":
    # علامات کی تعریف کریں
    m_sym, L_sym, g_sym = symbols('m L g')

    # حرکت کی مساوات حاصل کریں
    equation_of_motion = lagrangian_dynamics_single_pendulum_conceptual(m_sym, L_sym, g_sym)
    print("ایک واحد پینڈولم کے لیے حرکت کی مساوات (لاگرانجین):\n")
    print(equation_of_motion)

    # متوقع آؤٹ پٹ کچھ اس طرح ہونا چاہیے: m*L**2*Derivative(theta(t), (t, 2)) + g*L*m*sin(theta(t)) = 0
    # جو معیاری پینڈولم مساوات ہے: I*theta_double_dot + m*g*L*sin(theta) = 0
```

---
## 🆚 نیوٹن-ایولر بمقابلہ لاگرانجین: ایک موازنہ 📈

دونوں فارمولیشن برابر درست ہیں اور وہی ڈائینامک مساوات حاصل کریں گے۔ انتخاب اکثر روبوٹ کی پیچیدگی، مخصوص کام (مثلاً فارورڈ بمقابلہ معکوس ڈائینامکس)، اور ذاتی ترجیح پر منحصر ہوتا ہے۔

| خصوصیت | نیوٹن-ایولر | لاگرانجین |
| :-------------------- | :----------------------------------------------- | :------------------------------------------------ |
| **نقطہ نظر** | قوت/مومینٹ توازن، تکراری | توانائی پر مبنی، سکیلر مقداریں |
| **جھلک** | ہر ٹرم کے لیے زیادہ جھلک دینے والا جسمانی معنی | زیادہ م abstract، مجموعی نظام توانائی پر توجہ |
| **مساوات** | ہر لنک کے لیے بہت سارے ویکٹر مساوات، تکرار کے ساتھ | کم سکیلر مساوات (ہر DoF کے لیے ایک) |
| **اندرونی قوتیں** | براہ راست حساب، پھر ختم | توانائی کے اصولوں کے ذریعے خود بخود شامل |
| **معلوماتی لاگت** | اکثر معکوس ڈائینامکس کے لیے کارآمد | اکثر فارورڈ ڈائینامکس (سیمولیشن) کے لیے کارآمد (علامتی ماخذ) |
| **پیچیدگی** | کئی لنکس کے ساتھ پیچیدہ جیومیٹری کے لیے تکلیف دہ ہو سکتا ہے | پیچیدہ نظام کے لیے زیادہ منظم، نشان کی غلطیوں سے کم متاثر |
| **کے لیے بہتر** | معکوس ڈائینامکس (حقیقی وقت کنٹرول)، سادہ سیریل چینز | فارورڈ ڈائینامکس (سیمولیشن)، پیچیدہ نظام کے لیے علامتی ماخذ |

---
## خاتمہ: کنٹرول کی طرف پل 🌉

روبوٹ ڈائینامکس مطلوبہ حرکت اور اس کو حاصل کرنے کے لیے درکار قوتوں/ٹورکس کے درمیان اہم پل فراہم کرتا ہے۔ بغیر ایک مضبوط ڈائینامک ماڈل کے، روبوٹ کو مؤثر طریقے سے کنٹرول نہیں کیا جا سکتا۔ یہ انجینئرز کو یہ کرنے کے قابل بناتا ہے:

* **کنٹرولرز کا ڈیزائن:** الگورتھم تیار کریں جو منصوبہ بندہ ٹریجیکٹری کو درست طور پر فالو کرنے کے لیے ضروری جوڑ ٹورک کا حساب لگاتے ہیں، گریویٹی، انرشیا، اور بیرونی متغیرات کی معاوضہ کرتے ہوئے۔
* **سیمولیشن کریں:** حقیقی ورچوئل پروٹو ٹائپ تیار کریں تاکہ فزیکل ہارڈ ویئر پر ان کو ڈپلائے کرنے سے پہلے کنٹرول کے حکمت عملی اور روبوٹ کے رویے کو ٹیسٹ کیا جا سکے۔
* **کارکردگی کو بہتر بنائیں:** بہتر رفتار، درستگی، اور توانائی کی کارکردگی کے لیے جسمانی پیرامیٹر (ماس، لنک کی لمبائی) اور کنٹرول گینز کو فائن ٹیون کریں۔

یہ اصول کو سمجھنا اعلیٰ روبوٹکس کے ساتھ کام کرنے والے کسی بھی شخص کے لیے ایک ستون ہے، کنٹرول اور حرکت کی منصوبہ بندی کے بعد کے بابوں کے لیے بنیاد فراہم کر رہا ہے۔ جاری رکھیں! 🌟