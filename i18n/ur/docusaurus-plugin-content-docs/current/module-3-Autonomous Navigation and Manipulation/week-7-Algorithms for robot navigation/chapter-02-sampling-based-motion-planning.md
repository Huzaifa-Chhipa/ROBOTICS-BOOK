import PrerequisiteDisplay from '@site/src/components/PrerequisiteDisplay';

---
title: "نمونہ اخذ کاری پر مبنی موشن منصوبہ بندی"
description: "اعلیٰ طاقت والی جگہوں کو موثر طریقے سے تلاش کرنا۔"
slug: "chapter-02-sampling-based-motion-planning"
week: 7
module: "مODULE 3: خود کار نیویگیشن اور ہیرا پھیری"
prerequisites: ["chapter-01-graph-search-algorithms"]
learningObjectives:
  - روایتی گریف سرچ کی اعلیٰ طاقت والی جگہوں میں حدود کو سمجھیں۔
  - نمونہ اخذ کاری پر مبنی موشن منصوبہ بندی کے بنیادی اصولوں کو سمجھیں۔
  - Probabilistic RoadMap (PRM) الگورتھم اور اس کے تعمیر کے مراحل کو تلاش کریں۔
  - Rapidly-exploring Random Tree (RRT) الگورتھم کے بارے میں جانیں تاکہ موثر جگہ کی کھوج کے لیے۔
  - RRT اور RRT* کے درمیان تمیز کریں اور asymptotic optimality کے تصور کو سمجھیں۔
  - نمونہ اخذ کاری پر مبنی منصوبہ بندی کے مختلف روبوٹک منظر ناموں میں کارکردگی کو پہچانیں۔
estimatedTime: 120
difficultyLevel: "متوسط"
sidebar_label: "2. نمونہ اخذ کاری پر مبنی موشن منصوبہ بندی"
position: 2
---

<PrerequisiteDisplay prerequisites={frontMatter.prerequisites} />

# 🎲 نمونہ اخذ کاری پر مبنی موشن منصوبہ بندی: اعلیٰ طاقت والی دنیا میں نیویگیٹ کرنا

پچھلے باب میں، ہم نے موشن منصوبہ بندی کے لیے A* جیسے گریف سرچ الگورتھم کو تلاش کیا۔ جبکہ 2D گرڈ جیسے ڈسکریٹ اور نسبتاً کم طاقت والے ماحول کے لیے یہ انتہائی طاقتور ہیں، یہ الگورتھم ان کے ساتھ ایک نمایاں رکاوٹ کا سامنا کرتے ہیں جب بہت سے ڈگریز آف فریڈم (DoF) والے روبوٹس کے ساتھ کام کرتے ہیں یا جاری، پیچیدہ جگہوں میں کام کرتے ہیں۔ اس چیلنج کو **کرس آف ڈائمنشنا لٹی** کہا جاتا ہے۔ جیسے جیسے طاقتوں کی تعداد بڑھتی ہے، کنفیگریشن اسپیس کا سائز نمائندگی کے ساتھ بڑھ جاتا ہے، جس سے واضح گریف کی تعمیر (جیسے اکوپنسی گرڈ) کمپیوٹیشنل طور پر غیر ممکن ہو جاتا ہے۔ 🤯

یہی وہ جگہ ہے جہاں **نمونہ اخذ کاری پر مبنی موشن منصوبہ بندی کی تکنیکیں** ایک طاقتور متبادل کے طور پر سامنے آتی ہیں۔ ڈسکریٹائزڈ سپیس کو مکمل طور پر تلاش کرنے کے بجائے، یہ طریقے روبوٹ کی کنفیگریشن اسپیس میں نمایاں طور پر "نمونہ اخذ کاری" والے پوائنٹس (کنفیگریشنز) کو کام میں لاتے ہیں اور فری اسپیس کی ایک نمائندگی کو فلائی پر تعمیر کرتے ہیں۔ جب فری کنفیگریشن اسپیس (C-space) کی واضح نمائندگی (C-space) کا حساب لگانا بہت پیچیدہ یا ممکن نہ ہو تو یہ خاص طور پر مؤثر ہوتے ہیں۔ یہ باب ان موثر طریقوں کو متعارف کرائے گا، دو کون کے الگورتھم: **پرو بیبسٹک روڈ میپ (PRM)**، جو ماحول کا ایک قابل استعمال روڈ میپ تعمیر کرتا ہے، اور **ریپڈلی ایکسپلورنگ رینڈم ٹری (RRT)**، جو مقصد کی طرف تیز کھوج کے لیے ڈیزائن کیا گیا ہے۔ ہم RRT* (RRT-سٹار) میں بھی غور کریں گے، RRT کا ایک بہترین متغیر۔ ان منصوبہ سازوں کو سمجھنا اہم ہے تاکہ روبوٹس کو الجھن والی اور اعلیٰ طاقت والی جگہوں میں راستے تلاش کرنے کے قابل بنایا جا سکے، جو اعلیٰ روبوٹک ہیرا پھیری اور نیویگیشن میں ایک عام اور اہم چیلنج ہے۔ ✨

---
## طاقت کی لعنت اور کنفیگریشن اسپیس (C-Space) 🌌

نمونہ اخذ کاری والے طریقوں میں گہرائی سے جانے سے پہلے، آئیں ہم **کنفیگریشن اسپیس (C-Space)** کے تصور کو دوبارہ دیکھیں۔ کسی بھی روبوٹ کے لیے، اس کی کنفیگریشن اس کے تمام جوڑ اور لنکس کی بالکل حالت کو بیان کرتی ہے۔ C-space وہ تمام ممکنہ کنفیگریشنز کا مجموعہ ہے جو روبوٹ حاصل کر سکتا ہے۔

* **فری C-Space (C_free):** تمام کنفیگریشنز جہاں روبوٹ رکاوٹوں یا خود سے ٹکراتا نہیں ہے۔
* **آبستگی C-Space (C_obstacle):** تمام کنفیگریشنز جہاں روبوٹ ٹکراتا ہے۔

`n` ڈگریز آف فریڈم والے روبوٹ کے لیے، اس کا C-space `n`-ڈائمنشنل ہے۔
* ایک موبائل روبوٹ جو 2D ہموار پر چلتا ہے اس کے 3 DoF (`x, y, θ`) ہیں۔
* ایک 6-DoF روبوٹک آرم میں 6 جوڑ اینگلز ہیں۔

**طاقت کی لعنت** کا کہنا ہے کہ تلاش کی جگہ کا حجم طاقتوں کی تعداد کے ساتھ نمائندگی کے ساتھ بڑھ جاتا ہے۔ ایک زیادہ DoF والے روبوٹ کے لیے، C-space کو براہ راست ڈسکریٹائز کرنا (ایک گرڈ کے طور پر) نا قابل ہو جاتا ہے کیونکہ:
* **میموری:** ایک `n`-ڈائمنشنل گرڈ کو ذخیرہ کرنا۔
* **کمپیوٹیشن:** گرڈ میں ہر سیل کے لیے ٹکراؤ کی جانچ کرنا۔

نمونہ اخذ کاری والے منصوبہ ساز اسے C-space کو ضمنی طور پر تلاش کر کے ختم کر دیتے ہیں۔

---
## 🛣️ Probabilistic RoadMap (PRM): ایک قابل استعمال نقشہ تیار کرنا

**Probabilistic RoadMap (PRM)** الگورتھم ایک ملٹی-کویری منصوبہ ساز ہے۔ اس کا مطلب ہے کہ یہ ایک بار ماحول کا ایک روڈ میپ (ایک گریف) تعمیر کرتا ہے، اور پھر اس روڈ میپ کو بہت سے مختلف شروع اور مقصد کنفیگریشنز کے لیے راستے تلاش کرنے کے لیے استعمال کیا جا سکتا ہے۔ PRM ایسے روبوٹس کے لیے خاص طور پر مؤثر ہے جو مسلسل یا آہستہ تبدیل ہونے والے ماحول میں کام کرتے ہیں جہاں متعدد راستہ کویریز کی توقع ہوتی ہے۔

### PRM الگورتھم کے مراحل:

#### 1. لرننگ فیز (روڈ میپ کی تعمیر) 🛠️
یہ فیز آف لائن یا جب ماحول معلوم ہو تو انجام دیا جاتا ہے۔

* **نمونہ اخذ کاری:**
  * C-space میں ایک بڑی تعداد میں `N` کنفیگریشنز (نوڈس) `q_i` کو بے ترتیب طور پر تیار کریں۔
  * ہر نمونہ کنفیگریشن کے لیے، چیک کریں کہ کیا یہ ٹکراؤ سے پاک ہے (مثلاً `q_i ∈ C_free`)۔ ٹکراؤ والی حالتیں کو مسترد کر دیں۔
* **رابطہ:**
  * ہر درست `q_i` کے لیے، اس کے `k` قریبی ہمسایوں (یا ایک مخصوص رداس کے اندر تمام ہمسایوں) کو تلاش کریں۔
  * C-space میں سیدھی لکیر کے راستے سے `q_i` کو ان ہمسایوں سے جوڑنے کی کوشش کریں (یا سادہ مقامی منصوبہ ساز)۔
  * ہر ممکن ربط کے لیے، ایک **مقامی ٹکراؤ چیک** کریں (مثلاً راستے کو چھوٹے اسٹیپس میں ڈسکریٹائز کریں اور ہر اسٹیپ کے لیے ٹکراؤ کی جانچ کریں)۔ اگر راستہ ٹکراؤ سے پاک ہے، تو روڈ میپ گریف میں ایک کنارہ شامل کریں۔
  * کنارے کو اس کی لمبائی کے ذریعے وزن دیا جا سکتا ہے (C-space میں یوکلڈین فاصلہ)۔

#### 2. کویری فیز (راستہ تلاش) 🔎
یہ فیز آن لائن کیا جاتا ہے جب بھی راستہ کی ضرورت ہوتی ہے۔

* **شروع اور مقصد کو جوڑنا:**
  * روڈ میپ میں اس کے قریبی ہمسایوں کو تلاش کر کے اور ان کو ٹکراؤ سے پاک راستوں کے ساتھ جوڑ کر شروع کی کنفیگریشن `q_start` کو جوڑنے کی کوشش کریں۔
  * `q_goal` کنفیگریشن کے لیے بھی یہی کریں۔
* **تلاش:**
  * ایک بار جب `q_start` اور `q_goal` کو روڈ میپ سے جوڑ دیا جاتا ہے، تو روڈ میپ کے ذریعے `q_start` اور `q_goal` کے درمیان مختصر ترین راستہ تلاش کرنے کے لیے ایک معیاری گریف سرچ الگورتھم (جیسے ڈیکسٹرا یا A*، جیسا کہ پچھلے باب میں بحث کی گئی تھی) کا استعمال کیا جاتا ہے۔

### PRM کی خصوصیات:
* **م probabilistic مکمل:** کافی نمونے اور کنکشنز کے ساتھ، PRM کو یہ ضمانت ہے کہ اگر کوئی راستہ موجود ہے تو وہ اسے تلاش کرے گا۔
* **ملٹی-کویری کے لیے اچھا:** ایک بار جب روڈ میپ تیار ہو جاتا ہے، نئے راستوں کے لیے کویری تیز ہے۔
* **تنگ گزرگاہوں میں مشکل:** اگر مفت C-space میں تنگ گزرگاہیں ہیں، تو ان گزرگاہوں کو "دریافت" کرنے کے لیے بہت سے بے ترتیب نمونے درکار ہو سکتے ہیں، جس سے یہ غیر موثر ہو جاتا ہے۔

```python
# پائیتھن نمونہ کوڈ مثال: PRM تعمیر (سادہ)
import numpy as np
import random
import matplotlib.pyplot as plt

class ConfigurationSpace:
    """ایک سادہ 2D کنفیگریشن اسپیس کی نمائندگی کرتا ہے جس میں مستطیل رکاوٹیں ہیں۔"""
    def __init__(self, x_min, x_max, y_min, y_max, obstacles):
        self.x_min = x_min
        self.x_max = x_max
        self.y_min = y_min
        self.y_max = y_max
        self.obstacles = obstacles # (x, y, width, height) ٹوپل کی فہرست

    def is_collision_free(self, q):
        """چیک کرتا ہے کہ کیا کنفیگریشن q = (x, y) ٹکراؤ سے پاک ہے۔"""
        x, y = q
        # باؤنڈز چیک کریں
        if not (self.x_min <= x <= self.x_max and self.y_min <= y <= self.y_max):
            return False
        # رکاوٹوں کے خلاف چیک کریں (سادہ مستطیل ٹکراؤ)
        for ox, oy, ow, oh in self.obstacles:
            if ox < x < ox + ow and oy < y < oy + oh:
                return False
        return True

    def get_random_config(self):
        """ایک بے ترتیب کنفیگریشن تیار کرتا ہے۔"
        x = random.uniform(self.x_min, self.x_max)
        y = random.uniform(self.y_min, self.y_max)
        return (x, y)

    def is_path_collision_free(self, q1, q2, steps=10):
        """چیک کرتا ہے کہ q1 اور q2 کے درمیان سیدھی لکیر کا راستہ ٹکراؤ سے پاک ہے یا نہیں۔"
        for i in range(steps + 1):
            t = i / steps
            q_intermediate = (q1[0] * (1 - t) + q2[0] * t, q1[1] * (1 - t) + q2[1] * t)
            if not self.is_collision_free(q_intermediate):
                return False
        return True

def prm_construction_conceptual(c_space, num_samples, num_neighbors):
    """
    ایک Probabilistic Roadmap (PRM) تعمیر کرتا ہے۔
    آرگس:
        c_space (ConfigurationSpace): کنفیگریشن اسپیس آبجیکٹ۔
        num_samples (int): نمونہ کنفیگریشنز کی تعداد۔
        num_neighbors (int): رابطہ کی کوشش کرنے کے لیے قریبی ہمسایوں کی تعداد۔
    واپسی:
        ٹوپل: (نوڈس، ایجز) جو روڈ میپ گریف کی نمائندگی کرتا ہے۔
    "
    nodes = []
    # 1. نمونہ اخذ کاری فیز
    print(f"{num_samples} کنفیگریشنز کا نمونہ لے رہا ہے..."
    while len(nodes) < num_samples:
        q = c_space.get_random_config()
        if c_space.is_collision_free(q):
            nodes.append(q)

    edges = {} # ایڈجیسنسی لسٹ کی نمائندگی
    for q in nodes:
        edges[q] = []

    # 2. کنکشن فیز
    print(f"نمونہ کنفیگریشنز کو جوڑ رہا ہے (num_nodes={len(nodes)})..."
    for i, q1 in enumerate(nodes):
        # قریبی ہمسایوں کو تلاش کریں
        distances = []
        for j, q2 in enumerate(nodes):
            if i == j: continue
            dist = np.linalg.norm(np.array(q1) - np.array(q2))
            distances.append((dist, q2))

        distances.sort()

        for k_neighbor_dist, q2 in distances[:num_neighbors]:
            if c_space.is_path_collision_free(q1, q2):
                edges[q1].append((q2, k_neighbor_dist)) # ہمسایہ اور فاصلہ (وزن) ذخیرہ کریں
                edges[q2].append((q1, k_neighbor_dist)) # دو طرفہ کنارہ

    print("PRM تعمیر مکمل ہو گئی۔ 🗺️")
    return nodes, edges

if __name__ == "__main__":
    # ایک سادہ 2D C-Space کو رکاوٹوں کے ساتھ بیان کریں
    obstacles = [
        (2.0, 2.0, 1.0, 4.0), # (x, y, width, height)
        (6.0, 4.0, 2.0, 1.0)
    ]
    c_space_2d = ConfigurationSpace(0, 10, 0, 10, obstacles)

    # PRM تعمیر کریں
    num_samples = 100
    num_neighbors = 5
    nodes_prm, edges_prm = prm_construction_conceptual(c_space_2d, num_samples, num_neighbors)

    # PRM کو پلاٹ کرنا
    plt.figure(figsize=(8, 8))
    plt.xlim(c_space_2d.x_min, c_space_2d.x_max)
    plt.ylim(c_space_2d.y_min, c_space_2d.y_max)

    # رکاوٹیں ڈرائیں
    for ox, oy, ow, oh in c_space_2d.obstacles:
        plt.gca().add_patch(plt.Rectangle((ox, oy), ow, oh, fc='gray', ec='black'))

    # نوڈس ڈرائیں
    for q in nodes_prm:
        plt.plot(q[0], q[1], 'o', color='blue', markersize=3)

    # ایجز ڈرائیں
    for q1, neighbors in edges_prm.items():
        for q2, _ in neighbors:
            plt.plot([q1[0], q2[0]], [q1[1], q2[1]], 'k-', linewidth=0.5, alpha=0.5)

    plt.title('Probabilistic Roadmap (PRM) تعمیر')
    plt.xlabel('X-coordinate')
    plt.ylabel('Y-coordinate')
    plt.grid(True)
    plt.show()
    print("PRM وضاحت کے تصور کی مثال مکمل ہو گئی۔ ✅")
```

---
## 🌳 تیزی سے پھیلنے والا بے ترتیب درخت (RRT): موثر کھوج

**تیزی سے پھیلنے والا بے ترتیب درخت (RRT)** الگورتھم ایک سنگل-کویری منصوبہ ساز ہے، جس کا مطلب ہے کہ یہ ایک مخصوص کویری کے لیے ایک دیے گئے شروع اور مقصد کے درمیان راستہ تلاش کرنے کے لیے ایک درخت تعمیر کرتا ہے۔ RRT کو اعلیٰ طاقت والی C-spaces کی کارآمد کھوج کے لیے ڈیزائن کیا گیا ہے اور یہ کسی بھی راستہ کو تیزی سے تلاش کرنے کے لیے خاص طور پر اچھا ہے، چاہے یہ بہترین نہ ہو۔

### RRT الگورتھم کے اقدامات:

1. **درخت کو شروع کریں:** ایک درخت `T` کے روٹ کے طور پر ابتدائی کنفیگریشن `q_start` کے ساتھ شروع کریں۔
2. **بے ترتیب کنفیگریشن کا نمونہ لیں:** `C_space` سے ایک بے ترتیب کنفیگریشن `q_rand` تیار کریں۔
3. **قریبی ترین نوڈ تلاش کریں:** `T` میں وہ نوڈ `q_nearest` تلاش کریں جو `q_rand` کے سب سے قریب ہو (مثلاً C-space میں یوکلڈین فاصلہ استعمال کر کے)۔
4. **درخت کو بڑھائیں:** `q_nearest` سے `q_rand` کی طرف ایک مقررہ قدم کے سائز `Δq` کے ساتھ درخت کو بڑھانے کی کوشش کریں۔ اس کا نتیجہ ایک نئی کنفیگریشن `q_new` میں نکلتا ہے۔
    * `q_nearest` سے `q_new` تک راستے کے ساتھ ایک **مقامی ٹکراؤ چیک** کریں۔
    * اگر `q_new` ٹکراؤ سے پاک ہے اور راستہ ٹکراؤ سے پاک ہے، تو `q_new` کو `T` میں `q_nearest` کے بچے کے طور پر شامل کریں۔
5. **دہرائیں:** `q_new` `q_goal` کے کافی قریب ہونے تک قدم 2-4 دہرائیں۔
6. **راستہ نکالنا:** ایک بار جب درخت `q_goal` تک پہنچ جائے، تو `q_goal` سے `q_start` تک والدین کے اشاریوں کے ذریعے واپس جا کر راستہ تلاش کریں۔

### RRT کی خصوصیات:
* **probabilistic مکمل:** RRT probabilistically مکمل ہے۔
* **تیز کھوج:** بے ترتیب نمونہ اور توسیع کا عمل قدرتی طور پر درخت کو C-space کے نا معلوم علاقوں کی طرف تلاش کرنے کے لیے مائل کرتا ہے، جس سے کوئی راستہ تلاش کرنے کے لیے اسے موثر بنا دیتا ہے۔
* **غیر بہترین راستے:** بنیادی RRT کے ذریعے تلاش کردہ راستے عام طور پر بہترین نہیں ہوتے (اکثر جگیڈ اور ضرورت سے زیادہ لمبے ہوتے ہیں)۔
* **سنگل-کویری:** عام طور پر ہر نئے راستہ کویری کے لیے درخت کو دوبارہ تعمیر کرتا ہے۔
* **پابندیوں کو سنبھالنا:** `Extend` اسٹیپ میں غیر ہولونومک اور کنیموڈائینامک پابندیوں کو شامل کر سکتا ہے۔

```python
# پائیتھن نمونہ کوڈ مثال: RRT توسیع اسٹیپ (سادہ)
import numpy as np
import random
import matplotlib.pyplot as plt

class RRT_Node:
    def __init__(self, config, parent=None):
        self.config = config # (x, y)
        self.parent = parent

def rrt_extend_conceptual(c_space, tree, q_rand, step_size):
    """
    RRT الگورتھم کا ایک توسیع اسٹیپ انجام دیتا ہے۔
    آرگس:
        c_space (ConfigurationSpace): کنفیگریشن اسپیس آبجیکٹ۔
        tree (list): RRT_Node آبجیکٹس کی فہرست جو درخت کی نمائندگی کرتی ہے۔
        q_rand (tuple): بے ترتیب نمونہ کنفیگریشن۔
        step_size (float): توسیع کے لیے زیادہ سے زیادہ قدم کا سائز۔
    واپسی:
        RRT_Node یا None: اگر توسیع کامیاب ہوتی ہے تو نیا شامل کردہ نوڈ، بصورت دیگر None۔
    """
    # 1. q_nearest تلاش کریں
    q_nearest = min(tree, key=lambda node: np.linalg.norm(np.array(node.config) - np.array(q_rand)))

    # 2. q_nearest سے q_rand کی طرف بڑھائیں
    vector_to_rand = np.array(q_rand) - np.array(q_nearest.config)
    distance = np.linalg.norm(vector_to_rand)

    if distance < step_size:
        q_new_config = q_rand
    else:
        q_new_config = tuple(np.array(q_nearest.config) + (vector_to_rand / distance) * step_size)

    # 3. ٹکراؤ کی جانچ کریں
    if c_space.is_path_collision_free(q_nearest.config, q_new_config):
        q_new_node = RRT_Node(q_new_config, parent=q_nearest)
        tree.append(q_new_node)
        return q_new_node
    else:
        return None

if __name__ == "__main__":
    # PRM مثال سے C_space دوبارہ استعمال کریں
    obstacles = [
        (2.0, 2.0, 1.0, 4.0), # (x, y, width, height)
        (6.0, 4.0, 2.0, 1.0)
    ]
    c_space_2d = ConfigurationSpace(0, 10, 0, 10, obstacles)

    q_start = (1.0, 1.0)
    tree_rrt = [RRT_Node(q_start)]

    step_size = 0.5
    num_iterations = 200

    print("RRT توسیع ڈیمو شروع ہو رہا ہے۔ 🌳")
    for _ in range(num_iterations):
        q_rand = c_space_2d.get_random_config()
        rrt_new_node = rrt_extend_conceptual(c_space_2d, tree_rrt, q_rand, step_size)

    # RRT کو پلاٹ کرنا
    plt.figure(figsize=(8, 8))
    plt.xlim(c_space_2d.x_min, c_space_2d.x_max)
    plt.ylim(c_space_2d.y_min, c_space_2d.y_max)

    # رکاوٹیں ڈرائیں
    for ox, oy, ow, oh in c_space_2d.obstacles:
        plt.gca().add_patch(plt.Rectangle((ox, oy), ow, oh, fc='gray', ec='black'))

    # ٹری نوڈس اور ایجز ڈرائیں
    for node in tree_rrt:
        plt.plot(node.config[0], node.config[1], 'o', color='blue', markersize=2)
        if node.parent:
            plt.plot([node.config[0], node.parent.config[0]],
                     [node.config[1], node.parent.config[1]], 'k-', linewidth=0.5, alpha=0.5)

    plt.plot(q_start[0], q_start[1], 'o', color='green', markersize=8, label='Start')
    plt.title('RRT Tree Expansion')
    plt.xlabel('X-coordinate')
    plt.ylabel('Y-coordinate')
    plt.grid(True)
    plt.show()
    print("RRT وضاحت کے تصور کی مثال مکمل ہو گئی۔ ✅")
```

---
## RRT* (RRT-Star): بہترین راستوں کی طرف 🌟

RRT کا ایک بڑا نقصان یہ ہے کہ یہ راستے عام طور پر غیر بہترین ہوتے ہیں۔ **RRT* (RRT-Star)** RRT کا ایک اضافہ ہے جو اسے حل کرتا ہے جو **asymptotic optimality** کی ضمانت دیتا ہے: کافی نمونے اور وقت کے ساتھ، RRT* کے ذریعہ تلاش کردہ راستہ مختصر ممکنہ راستہ کی طرف متقارب ہو جائے گا۔

### RRT* میں کلیدی اضافے:

1. **پیرنٹ کا انتخاب (موجودہ سے دوبارہ وائر):** جب ایک نیا نوڈ `q_new` تیار کیا جاتا ہے، صرف اسے `q_nearest` سے جوڑنے کے بجائے، RRT* اس کے ماحول میں تمام نوڈس پر غور کرتا ہے (`q_near`)۔ پھر یہ `q_near` میں سے وہ پیرنٹ منتخب کرتا ہے جس کے نتیجے میں `q_start` سے `q_new` تک کا سب سے کم قیمت والا راستہ نکلتا ہے۔
2. **دوبارہ وائر:** `q_new` کو درخت میں شامل کرنے کے بعد، RRT* چیک کرتا ہے کہ کیا `q_new` کو `q_near` میں کسی دوسرے نوڈ `q_in_near` سے جوڑنا `q_start` سے `q_in_near` تک *موجودہ راستہ سے کم قیمت* کا راستہ فراہم کرے گا۔ اگر ہاں، تو `q_in_near` کو `q_new` کا بچہ بنایا جاتا ہے۔

یہ دو اقدامات RRT* کو مسلسل بہترین درخت کو بہتر بنانے کی اجازت دیتے ہیں کیونکہ مزید نمونے شامل ہوتے ہیں، جس سے وقت کے ساتھ ہموار اور چھوٹے راستے نکلتے ہیں۔

### RRT* کی خصوصیات:
* **asymptotic کارآمدی:** راستہ کی قیمت اس وقت تک متقارب ہوتی ہے جب نمونوں کی تعداد لامحدود ہو جائے۔
* **probabilistic مکمل:** RRT کی طرح، یہ بھی یقینی طور پر ایک راستہ تلاش کرے گا اگر ایک موجود ہو۔
* **RRT سے سست:** `ChooseParent` اور `Rewire` اسٹیپس کمپیوٹیشنل اضافی خرچ شامل کرتے ہیں، جس سے ہر اسٹیپ RRT سے سست ہو جاتا ہے۔

---
## نمونہ اخذ کاری پر مبنی منصوبہ سازوں کا موازنہ 📊

| خصوصیت | Probabilistic Roadmap (PRM) | Rapidly-exploring Random Tree (RRT) | RRT* (RRT-Star) |
| :------------------------- | :---------------------------------------------- | :---------------------------------------------- | :---------------------------------------------- |
| **طریقہ** | C-space میں ایک گریف (روڈ میپ) تعمیر کرتا ہے | شروع سے ایک درخت بڑھاتا ہے | ایک درخت بڑھاتا ہے، مسلسل بہتر بناتا ہے |
| **مکمل** | Probabilistic Complete | Probabilistic Complete | Probabilistic Complete |
| **بہترین** | بہترین (اگر بنیادی گریف سرچ بہترین ہو، مثلاً A*) | غیر بہترین (کوئی بھی راستہ تلاش کرتا ہے) | Asymptotically بہترین |
| **ملٹی-کویری** | ہاں (روڈ میپ دوبارہ استعمال کر سکتے ہیں) | نہیں (سنگل کویری) | نہیں (سنگل کویری) |
| **کمپیوٹیشنل خرچہ** | زیادہ آف لائن فیز، تیز آن لائن کویری | سنگل کویری کے لیے تیز | RRT کے مقابلے میں فی اسٹیپ سست (_OPTIMIZATION_ کی وجہ سے) |
| **تنگ گزرگاہوں کو سنبھالنا** | مشکل ہو سکتا ہے (گھنی نمونہ اخذ کاری کی ضرورت) | اچھی طرح تلاش کرتا ہے | اچھی طرح تلاش کرتا ہے، تنگ گزرگاہوں میں راستے کو بہتر بناتا ہے |
| **مناسب** | مسلسل ماحول، متعدد راستہ کی درخواستیں | متحرک ماحول، تیز راستہ تلاش | متحرک ماحول، بہترین راستہ تلاش (وقت کے ساتھ) |

---
## 🚀 روبوٹکس میں نمونہ اخذ کاری پر مبنی موشن منصوبہ بندی کی ایپلی کیشنز

نمونہ اخذ کاری والے منصوبہ ساز پیچیدہ روبوٹک رویوں کو فعال کرنے کے لیے ضروری ہیں:

* **روبوٹک مینیپولیشن:** الجھن والے ورک اسپیس میں اعلیٰ DoF والے روبوٹک آرمز کے لیے ٹکراؤ سے پاک حرکات کی منصوبہ بندی (مثلاً مینوفیکچرنگ، سروس روبوٹکس، سرجریکل روبوٹس)۔
* **خود کار ڈرائیونگ:** پارکنگ، لین تبدیلی، یا تعمیراتی زونز کے ذریعے نیویگیٹ کرنے جیسے پیچیدہ منظر ناموں میں مقامی راستہ منصوبہ بندی کے لیے استعمال ہوتا ہے۔
* **ہیومنوڈ روبوٹ لوموکشن:** پیچیدہ ہیومنوڈ روبوٹس کے لیے مستحکم اور ٹکراؤ سے پاک مکمل جسم کی حرکات کی منصوبہ بندی۔
* **ہوائی گاڑیاں (ڈرون):** پیچیدہ 3D ماحول کے ذریعے ڈرونز کے لیے راستہ تلاش کرنا، رکاوٹوں سے بچنا اور ایک ہدف تک پہنچنا۔
* **خطرناک ماحول میں روبوٹکس:** آفات کے علاقوں یا خلا میں تلاش اور نیویگیٹ کرنا، جہاں ایک واضح نقشہ دستیاب نہ ہو یا بہت پیچیدہ ہو۔

---
## خاتمہ: روبوٹ نیویگیشن کی مہارت کا ماسٹر 🌟

نمونہ اخذ کاری پر مبنی موشن منصوبہ بندی الگورتھم ٹریڈیشنل گرڈ بیسڈ ا approaches کے مقابلے میں اعلیٰ DoF والے روبوٹک سسٹم میں طاقت کی لعنت کے حل کے لیے ایک طاقتور پیراڈائم شفٹ کی نمائندگی کرتے ہیں، elegant حل فراہم کرتے ہیں۔ PRM اسٹیٹک ماحول میں متعدد کویری کے منظر ناموں کے لیے ایک مضبوط فریم ورک فراہم کرتا ہے، جبکہ RRT اور اس کا بہترین متغیر، RRT*، پیچیدہ جگہوں کو تلاش کرنے اور بالآخر بہترین راستے تلاش کرنے میں تیزی سے کام کرتے ہیں۔ ان تکنیکوں کو سمجھ کر اور لاگو کر کے، روبوٹکسٹس خود کار سسٹم کو پیچیدہ ماحول میں نیویگیٹ کرنے، پیچیدہ ہیرا پھیری کر نے، اور اپنے اہداف کو بے مثال کارکردگی اور مطیعیت کے ساتھ حاصل کرنے کے قابل بناتے ہیں۔ ذہین روبوٹ نیویگیشن کا سفر واقعی اچھی طرح نمونہ لیے گئے راستوں کے ساتھ ہموار کیا گیا ہے! ✨