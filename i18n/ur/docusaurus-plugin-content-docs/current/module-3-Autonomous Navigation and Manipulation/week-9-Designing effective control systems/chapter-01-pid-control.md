import PrerequisiteDisplay from '@site/src/components/PrerequisiteDisplay';

---
title: "PID کنٹرول"
description: "روبوٹس کے لیے بنیادی فیڈ بیک کنٹرول."
slug: "chapter-01-pid-control"
week: 9
module: "مODULE 3: خود کار نیویگیشن اور ہیرا پھیری"
prerequisites: ["chapter-02-dynamic-trajectories"]
learningObjectives:
  - PID کنٹرول کے تصورات کو سمجھیں۔
estimatedTime: 45
difficultyLevel: "متوسط"
sidebar_label: "1. PID کنٹرول"
position: 1
---

<PrerequisiteDisplay prerequisites={frontMatter.prerequisites} />

# 🎛️ PID کنٹرول: روبوٹس کے لیے بنیادی فیڈ بیک کنٹرول

یہ باب روبوٹس کے لیے بنیادی فیڈ بیک کنٹرول کا جائزہ لیتا ہے، پروپورشل-انٹیگرل-ڈیریویٹو (PID) کنٹرولر میں گہرائی سے جاتا ہے۔ پچھلے تعارف کو بنیاد بنا کر، ہم اب PID کنٹرولر کی ریاضیاتی فارمولیشن کا جائزہ لیں گے اور منظم طریقے سے ہر ایک کے اثر کا تجزیہ کریں گے:

* **پروپورشل ٹرم (P):** فوری غلطی کی اصلاح کے لیے
* **انٹیگرل ٹرم (I):** مستقل حالت کی غلطی کو ختم کرنے کے لیے
* **ڈیریویٹو ٹرم (D):** دھماکوں کو کم کرنے اور مستقبل کی غلطیوں کی پیش گوئی کے لیے

ہم PID گینز کو ٹیون کرنے کے مختلف طریقے، جیسے زیگلر-نچلس کا طریقہ اور تجربہ اور غلطی کے طریقے، کا بھی جائزہ لیں گے۔ ہم کلاسیکل PID کنٹرول کی حدود کو بھی حل کریں گے، خاص طور پر انتہائی غیر لکیری یا غیر یقینی روبوٹک سسٹم میں، جو زیادہ اعلی کنٹرول حکمت عملیوں کے لیے راہ ہموار کرتا ہے۔ روبوٹ جوڑوں اور اینڈ ایفیکٹر کنٹرول میں PID نافذ کاری کی عملی مثالیں پیش کی جائیں گی۔ ✨

---
## PID کنٹرول کیا ہے؟ 🤔

**PID کنٹرولر** ایک فیڈ بیک کنٹرولر ہے جو کنٹرول ایکشن کا حساب لگانے کے لیے ایک ان پٹ سگنل (سیٹ پوائنٹ) اور ایک آؤٹ پٹ سگنل (پروسیس ویریبل) کے درمیان غلطی کے تین اجزاء (پروپورشل، انٹیگرل، اور ڈیریویٹو) کو استعمال کرتا ہے۔ یہ ایک روبوٹ کے سینسر ڈیٹا کو دیکھتا ہے اور اس کے مطلوبہ سیٹ پوائنٹ سے فرق کے مطابق اس کے ایکٹو ایٹر کو ایڈجسٹ کرتا ہے۔

### PID کا ریاضیاتی فارمولیشن:

`u(t) = Kp * e(t) + Ki * ∫e(t)dt + Kd * de(t)/dt`

جہاں:
* `u(t)`: کنٹرولر کا آؤٹ پٹ (مثلاً ٹورک، وولٹیج)
* `e(t)`: غلطی = سیٹ پوائنٹ - پروسیس ویریبل (SP - PV)
* `Kp`: پروپورشل گین
* `Ki`: انٹیگرل گین
* `Kd`: ڈیریویٹو گین

---
## PID کے تین ٹرمس 🧮

### 1. پروپورشل ٹرم (P) ⚖️

**اصول:** غلطی کے تناسب سے کنٹرول ایکشن پیدا کرتا ہے۔

`P_term = Kp * e(t)`

* **کردار:** فوری غلطی کی اصلاح کرتا ہے۔
* **اثر:**
  * **Kp میں اضافہ:** سسٹم کو تیز کرتا ہے، اٹھانے کا وقت کم کرتا ہے۔
  * **Kp میں اضافہ:** اکثر اوور شوٹ میں اضافہ کرتا ہے۔
  * **Kp بہت زیادہ:** اسکولیشن یا ناقابل استحکامی کا سبب بن سکتا ہے۔
* **نقصانات:** صرف موجودہ غلطی کو دیکھتا ہے، مستقل حالت کی غلطی کو ختم نہیں کر سکتا۔

### 2. انٹیگرل ٹرم (I) 📈

**اصول:** وقت کے ساتھ جمع ہونے والی غلطی کو سنبھالتا ہے۔

`I_term = Ki * ∫e(t)dt`

* **کردار:** مستقل حالت کی غلطی کو ختم کرتا ہے۔
* **اثر:**
  * **Ki میں اضافہ:** مستقل حالت کی غلطی کو تیزی سے ختم کرتا ہے۔
  * **Ki میں اضافہ:** اکثر اوور شوٹ اور سیٹلمنٹ ٹائم میں اضافہ کرتا ہے۔
  * **Ki بہت زیادہ:** اسکولیشن یا ناقابل استحکامی کا سبب بن سکتا ہے۔
* **نکات:** "انٹیگریٹر ونڈ اپ" کا مسئلہ ہو سکتا ہے جہاں I_ٹرم بہت زیادہ ہو جاتا ہے اور اوور شوٹ کا سبب بنتا ہے۔

### 3. ڈیریویٹو ٹرم (D) 📉

**اصول:** غلطی کی تبدیلی کی شرح کو سنبھالتا ہے۔

`D_term = Kd * de(t)/dt`

* **کردار:** مستقبل کی غلطیوں کی پیش گوئی کرتا ہے اور دھماکوں کو کم کرتا ہے۔
* **اثر:**
  * **Kd میں اضافہ:** اوور شوٹ کو کم کرتا ہے۔
  * **Kd میں اضافہ:** سیٹلمنٹ ٹائم کو کم کرتا ہے۔
  * **Kd بہت زیادہ:** نوائز کے جواب میں نا مطابقت پذیر ہو سکتا ہے۔
* **نکات:** نوائز کے جواب میں حساس، اکثر ڈیریویٹو فلٹر کی ضرورت ہوتی ہے۔

---
## PID ٹیوننگ کے طریقے 🎚️

PID گینز (Kp، Ki، Kd) کو ٹیون کرنا اہم ہے تاکہ بہترین کارکردگی حاصل کی جا سکے۔

### 1. تجربہ اور غلطی کا طریقہ 🧪

* **اصول:** گینز کو تجربہ کر کے اور ریسپانس کو دیکھ کر ہاتھ سے ایڈجسٹ کرنا۔
* **کام کا طریقہ:**
  1. صرف Kp کو ایک چھوٹی قیمت پر سیٹ کریں، Ki اور Kd کو 0 رکھیں۔
  2. Kp کو اس وقت تک بڑھائیں جب تک کہ سسٹم جواب دینا شروع کر دے۔
  3. Ki کو اس وقت تک بڑھائیں جب تک کہ مستقل حالت کی غلطی ختم نہ ہو جائے۔
  4. Kd کو اس وقت تک بڑھائیں جب تک کہ اوور شوٹ کم نہ ہو جائے۔
* **فوائد:** سادگی، کمپیوٹیشنل کم خرچ۔
* **نقصانات:** وقت لگنے والا، بہترین کارکردگی کی ضمانت نہیں۔

### 2. زیگلر-نچلس کا طریقہ 📊

* **اصول:** ایک نظام کے لیے ایک متغیر سسٹم کو تلاش کرتا ہے اور پھر اس کے لیے PID گینز کے لیے تجرباتی فارمولے استعمال کرتا ہے۔
* **کام کا طریقہ:**
  1. Ki اور Kd کو 0 پر سیٹ کریں۔
  2. Kp کو اس وقت تک بڑھائیں جب تک کہ سسٹم مستقل اسکولیشن کرنا شروع کر دے۔
  3. اسکولیشن کی کرختی (Ku) اور فریکوئنسی (Pu) کو نوٹ کریں۔
  4. فارمولے استعمال کریں:
     * Kp = 0.6 * Ku
     * Ki = 2 * Kp / Pu
     * Kd = Kp * Pu / 8
* **فوائد:** منظم، کارآمد، اکثر اچھی کارکردگی کی ضمانت دیتا ہے۔
* **نقصانات:** لکیری سسٹم کے لیے ڈیزائن کیا گیا، غیر لکیری سسٹم کے لیے کم مؤثر ہو سکتا ہے۔

```python
# پائیتھون نمونہ کوڈ مثال: PID کنٹرولر
class PIDController:
    def __init__(self, Kp, Ki, Kd, setpoint=0):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.setpoint = setpoint

        self.previous_error = 0
        self.integral = 0

    def update(self, current_value, dt):
        """
        PID کنٹرولر کا ایک اپ ڈیٹ اسٹیپ انجام دیتا ہے۔
        آرگس:
            current_value: موجودہ پروسیس ویریبل کی قیمت۔
            dt: پچھلے اپ ڈیٹ کا وقت۔
        واپسی:
            float: کنٹرول اؤٹ پٹ۔
        """
        error = self.setpoint - current_value

        # انٹیگرل کا حساب لگائیں
        self.integral += error * dt

        # ڈیریویٹو کا حساب لگائیں
        derivative = (error - self.previous_error) / dt if dt > 0 else 0

        # PID آؤٹ پٹ کا حساب لگائیں
        output = self.Kp * error + self.Ki * self.integral + self.Kd * derivative

        # اگلا اپ ڈیٹ کے لیے محفوظ کریں
        self.previous_error = error

        return output

# مثال کا استعمال
pid = PIDController(Kp=1.0, Ki=0.1, Kd=0.05, setpoint=10.0)

current_pos = 0.0
for i in range(100):
    control_output = pid.update(current_pos, dt=0.01)
    # سادہ مثال کے لیے، ہم فرض کرتے ہیں کہ کنٹرول آؤٹ پٹ رفتار ہے
    current_pos += control_output * 0.01  # dt = 0.01
    if i % 10 == 0:
        print(f"Time step {i}: Position={current_pos:.2f}, Control={control_output:.2f}")

print("PID کنٹرولر کی مثال مکمل ہو گئی۔ ✅")
```

---
## PID کنٹرول کی ایپلی کیشنز 🤖

* **روبوٹک جوڑ کنٹرول:** روبوٹک بازؤں کے جوڑوں کو مطلوبہ زاویہ تک لے جانے اور وہاں رکھنے کے لیے۔
* **سپیڈ کنٹرول:** روبوٹ کے پہیوں کی رفتار کو مطلوبہ رفتار تک برقرار رکھنے کے لیے۔
* **اینڈ ایفیکٹر کنٹرول:** گریپر کے جوڑوں کو کنٹرول کرنا تاکہ چیزیں درست طریقے سے تھامی جا سکیں۔
* **سٹیبلائزیشن:** ہیومنوڈ روبوٹس یا ڈرون کو توازن میں رکھنے کے لیے۔

### PID کی حدود:

* **غیر لکیری سسٹم:** PID کو لکیری سسٹم کے لیے ڈیزائن کیا گیا ہے، غیر لکیری سسٹم میں اس کی کارکردگی خراب ہو سکتی ہے۔
* **ماڈل کی عدم یقینی:** اگر سسٹم کا ماڈل درست نہیں ہے، تو PID کنٹرول کی کارکردگی خراب ہو سکتی ہے۔
* **رکاوٹیں:** PID کو رکاوٹوں کو ڈیزائن میں شامل نہیں کیا گیا ہے، جس سے اس کی کارکردگی میں محدودیت آ سکتی ہے۔

---
## خاتمہ: کنٹرول کی بنیاد 🏗️

PID کنٹرول ایک انتہائی قیمتی اور وسیع پیمانے پر استعمال ہونے والا کنٹرول ٹیکنیک ہے جو روبوٹکس اور دیگر انجنیئرنگ کے شعبوں میں استعمال ہوتی ہے۔ اس کی سادگی، سمجھنا، اور کارکردگی کی وجہ سے، PID کو اکثر کنٹرول سسٹم ڈیزائن کا "سونچیل ہیڈ" سمجھا جاتا ہے۔ ہر چیز کو مدنظر رکھتے ہوئے، زیادہ پیچیدہ اور کارآمد کنٹرول حکمت عملیوں کی طرف جانے کے لیے یہ ایک اہم بنیاد فراہم کرتا ہے، جیسے میڈل پریڈکٹو کنٹرول (MPC) یا آپٹیمل کنٹرول، جو زیادہ غیر لکیری اور غیر یقینی ماحول کے لیے بہتر ہیں۔ PID کنٹرول کو سمجھنا کسی بھی روبوٹک کنٹرول سسٹم کے ڈیزائن کے لیے ناگزیر ہے۔ اپنے روبوٹس کو کنٹرول کریں! ✨